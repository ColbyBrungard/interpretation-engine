
---
output:
  html_vignette:
    mathjax: null
    jquery: null
    smart: no
    keep_md: TRUE
---

  
```{r setup, echo=FALSE, results='hide', warning=FALSE}
library(knitr, quietly = TRUE)
library(printr, quietly = TRUE)
opts_chunk$set(message=FALSE, warning=FALSE, fig.retina = 2, fig.align='center', dev='png', dev.args=list(pointsize=10, antialias='cleartype'), tidy=FALSE)
options(width=500, stringsAsFactors=FALSE)

knit_hooks$set(htmlcap = function(before, options, envir) {
  if(!before) {
    paste('<p class="caption" style="font-size:85%; font-style: italic; font-weight: bold;">',options$htmlcap,"</p><hr>",sep="")
  }
})
```


Extracting NASIS Rules/Evaluations
========================================

```{r, fig.width=6, fig.height=4}
library(soilDB)
library(RODBC)
library(XML)
library(plyr)
library(data.tree)
library(digest)
library(jsonlite)

# source local functions
source('local-functions.R')

# re-load cached data
# getAndCacheData()

# load cached data
load('cached-NASIS-data.Rda')
```


## Evaluation Curves
Someimes the property min/max values are crazy, you can manually set plot limits with `xlim` argument.
```{r, fig.width=6, fig.height=4}
# arbitrary curve:
e <- evals[evals$evalname == '*Storie Factor C Slope 0 to 100%', ]
plotEvaluation(e, xlim=c(0, 200))

# get a function to describe the evaluation
s <- seq(0, 100, length.out = 10)
f <- extractEvalCurve(e)
cbind(domain=s, fuzzy.rating=f(s))

## sigmoid:
e <- evals[evals$evalname == 'SAR, WTD_AVG 0 to 100cm', ]
plotEvaluation(e, xlim=c(0,25))

# arbitrary linear
e <- evals[evals$evalname == 'GRL - EC maximum in depth 25 to 50 cm (NV)', ]
plotEvaluation(e, xlim=c(0, 1000))

# linear
e <- evals[evals$evalname == 'Slope 0 to >15%', ]
plotEvaluation(e)

# crisp:
e <- evals[evals$evalname == 'Soil pH (water) >= 4.5 and <= 8.4, 0-100cm', ]
plotEvaluation(e)

e <- evals[evals$evalname == 'Available Water Capacity <10cm', ]
plotEvaluation(e)
```



## Rule Trees
* check a couple, RefId points to rows in rules or evaluation tables
* the dt$Do call links child sub-rules
* recursion is used to traverse to the deepest nodes, seems to work
* **caution:** don't run several times on the same object!
* increase limit argument to see the entire tree

```{r, fig.width=6, fig.height=4}
# just some random rule
y <- rules[rules$rulename == 'Dust PM10 and PM2.5 Generation', ]
dt <- parseRule(y)
# print intermediate results
print(dt, 'Type', 'Value', 'RefId', 'rule_refid', 'eval_refid', limit=25)
# recusively splice-in sub-rules
dt$Do(traversal='pre-order', fun=linkSubRules)
# splice-in evaluation functions, if possible
dt$Do(traversal='pre-order', fun=linkEvaluationFunctions)
print(dt, 'Type', 'Value', 'RefId', 'rule_refid', 'eval_refid', 'evalType', limit=25)
```

Get a table of evaluations and properties
```{r, fig.width=6, fig.height=4}
getPropertySet(dt)
```


### More Examples

**California Revised Storie Index**
```{r, fig.width=6, fig.height=4}
y <- rules[rules$rulename == 'AGR - California Revised Storie Index (CA)', ]
dt <- parseRule(y)
dt$Do(traversal='pre-order', fun=linkSubRules)
dt$Do(traversal='pre-order', fun=linkEvaluationFunctions)
print(dt, 'Type', 'Value', 'RefId', 'rule_refid', 'eval_refid', 'evalType', limit=25)
```

```{r, fig.width=6, fig.height=4}
ps <- getPropertySet(dt)
unique(ps$property)
```


```{r, fig.width=6, fig.height=4}
y <- rules[rules$rulename == 'Commodity Crop Productivity Index (Corn) (WI)', ]
dt <- parseRule(y)
dt$Do(traversal='pre-order', fun=linkSubRules)
dt$Do(traversal='pre-order', fun=linkEvaluationFunctions)
print(dt, 'Type', 'Value', 'RefId', 'rule_refid', 'eval_refid', 'evalType', limit=25)



y <- rules[rules$rulename == 'DHS - Catastrophic Mortality, Large Animal Disposal, Pit', ]
dt <- parseRule(y)
dt$Do(traversal='pre-order', fun=linkSubRules)
dt$Do(traversal='pre-order', fun=linkEvaluationFunctions)
print(dt, 'Type', 'Value', 'RefId', 'rule_refid', 'eval_refid', 'evalType', limit=25)


# this one has a single RuleEvaluation: RefId points to rows in evals table
y <- rules[rules$rulename == 'Clay %, in surface - MO2', ]
dt <- parseRule(y)
dt$Do(traversal='pre-order', fun=linkSubRules)
dt$Do(traversal='pre-order', fun=linkEvaluationFunctions)
print(dt, 'Type', 'Value', 'RefId', 'rule_refid', 'eval_refid', 'evalType', limit=25)
```

## Conversion to JSON and D3 Vizualization
The objects can't have evaluation functions attached
```{r, eval=FALSE}
library(networkD3)
library(jsonlite)

y <- rules[rules$rulename == 'Dust PM10 and PM2.5 Generation', ]
dt <- parseRule(y)
dt$Do(traversal='pre-order', fun=linkSubRules)

# convert to list
dt.list <- ToListExplicit(dt, unmame=TRUE, childrenName = 'Children')

# convert to JSON
dt.json <- toJSON(dt.list, pretty = TRUE, auto_unbox = TRUE, null='null')
cat(dt.json, file='D3/dt.json')


net <- ToDataFrameNetwork(dt)
simpleNetwork(net, fontSize = 12)

# doesn't work
# radialNetwork(dt.list)

# test with:
# "C:\Program Files (x86)\PYTHON27\ArcGIS10.1\python.exe" -m SimpleHTTPServer

```


